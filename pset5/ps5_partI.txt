David Kalish
davidpkalish@gmail.com
CSCI E66
pset5
5/2/18

1: Logging and Recovery
    1.1 undo-redo
        A: 150
        B: 510, 570
        C: 430
        D: 200, 210

    1.2 redo-only
        A: 150
        B: 510
        C: 430
        D: 200
        Disk is only written to on commits; committed transactions and dirty
        log records are written. So only values before Record 60 are written.

    1.3 undo-only
        A: 150
        B: 510
        C: 400
        D: 200
        Disk written at commit. Only write DB pages changed by committed TXN,
        so Record 30 is not written because it was changed by txn2, but only
        txn1 was committed

    1.4 undo-redo recovery steps (no LSNs)
        1. undo: B = 510
        2. undo: D = 200
        3. add txn1 to commit list
        4. undo: C = 400
        5. redo: A = 130
        6. redo: A = 150
        7. redo: B = 510

    1.5 undo-redo recovery steps (with LSNs) A:0 B:50 C:0 D:70
        1. 70 = 70; undo: D = 200, datum LSN = 0
        2. add txn1 to commit list
        3. 0 = 0; redo: A = 130, datum LSN = 10
        4. 10=10; redo: A = 150, datum LSN = 40

    1.6 add dynamic checkpoint between records 30 and 40, change answer to 1.4
        1. active TXNs at checkpoint: txn1 and txn2
        2. undo: C = 400
        3. redo: A = 150
        4. redo: B = 510


2: Data Models for a NoSQL Document Database
    2.1.
        song document
        {
            _id: "0123456789",
            name: "Brave",
            duration: 219,
            genre: "pop",
            best_chart_rank: 23,
            royalties_due: 1200.00
        }

        artist document
        {
            _id: "9876543",
            name: "Sara Bareilles",
            label: "Epic",
            dob: "1979-12-07",
            primary_genre: "pop"
        }

        sings document
        {
            _id: "0123456789",
            artistID: "9876543"
        }

        played document
        {
            _id: "0123456789",
            date: "2015-04-22",
            time: "17:00"
        }


    2.2: advantage: less redundancy. Many songs have the same artist, so this
        way, each song can point to the same entry in the Artist document
        instead of possibly being embedded in the Sings document, or songs
        being embedded in the Played document.

        disadvantage: needs to make more requests to complete an operation,
        because it needs to search multiple documents

    2.3
        Song document
        {
            _id: "0123456789"
            name: "Brave",
            duration: 219,
            genre: "pop",
            best_chart_rank: 23,
            royalties_due: 1200.00,
            played: {
                        date: "2015-04-22",
                        time: "17:00"
                    },
            artist: {
                        name: "Sara Bareilles",
                        label: "Epic",
                        dob: "1979-12-07",
                        primary_genre: "pop"
                    }
        }

    2.4 advantage: fewer requests for an operation since everything is in one
        document and embedded.

        disadvantage: there will be duplicate information (and possible to
        introduce inconsistencies). When another song by Sara Bareilles is added
        to the database, all her Artist data will be re-embedded into the new
        song's entry

    2.5 Using the reference-based approach, when a customer plays a song, the
        Played document will be updated with a new entry containing the ID of
        the song being played, and the date/time that it was played.  The
        royalties_due field will be updated based on how many times the song
        appears in the Played document.

        Using embedded relationships, a new Played sub-document will be added
        with the date/time it was played.The royalties_due field will be
        updated based on how many Played sub-documents appear in the Song's
        document.

3: Two-phase commit
    3.1

    1. receive Prepare message
    2. force all dirty log records to disk
    3. force database pages changed by the txn to disk
    4. write the commit log record
    5. force the commit log record to disk
    6. report ready-to-commit


    3.2

    Once the coordinator recovers, it checks its sites to see what state they
    are in.  
    -   If a site hasn't received a prepare message for T or if it's been
    told to prepare but hasn't sent the ready message yet, the coordinator can
    abort T.
    -   If a site has received a prepare message and sent back a ready message, 
    but the coordinator didn't tell the site to commit/abort, it checks the
    other sites.  
        -   If other sites have commit records, then the coordinator must have
        sent a commit that those sites have received, so the coordinator can 
        send this site another commit message.
        -   If other sites have abort records, then the coordnator must have
        sent an abort to them and can send a new abort message to this site.
        -   If other sites have no commit or abort records, and at least one 
        doesn't have a ready record either, the coordinator aborts T because it
        must not have committed.
        -   If all sites have ready records but no commit/abort records, the
        coordinator must check its own record to try andsee what it was going
        to do.
